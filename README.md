Данный проект представляет собой движок для создания **браузерных многопользовательских игр**. Он выделился в самостоятельный проект в процессе разработки игры [https://kaerton.ru](https://kaerton.ru).

# Подготовка
- серверная часть движка работает на node.js, соответственно, он должен быть установлен в системе - https://nodejs.org/
- установка движка:
 `git clone https://github.com/progvlad/engine.git && cd engine && npm install`
- в папке examples есть несколько примеров работы с движком:
  - quest - пример текстовой квест-игры. Несколько сцен, каждая из нескольких простых компонент;
  - chat - набросок чата. Одна сцена, один компонент сцены и один компонент игры;
  - maze - полноценная реализация сложного компонента Лабиринт, с генерацией, хождением, проверками и т.д.
- **настоятельно** рекомендуется начать ознакомление с движком (после или во время чтения документации) именно с этих примеров - код их довольно прост и содержит множество комментариев. Начинать знакомиться с примерами лучше с файлов `src/game.coffee` - в них описана структура игр, как набор компонентов и сцен;
- для запуска любого примера необходимо зайти в его папку, запустить `npm start` и открыть в браузере выведенную в консоли ссылку, например, для чата это будет - [http://localhost:5320/](http://localhost:5320/)

# Структура игр

Основной идеей, заложенной в движок, является реализация игры через набор компонент. Есть компоненты всей игры (пример - `examples/chat/src/time/`), и есть компоненты сцен. При этом компоненты игры создаются в единственном экземпляре, а компоненты сцен - по одному экземпляру на сцену.

## Сцены

- создание игры начинается с файла, в котором задаются сцены и их компоненты (по умолчанию `src/game.coffee`, можно задать другое имя в поле `main` файла `package.json`)
- сцена, с которой начинает новый игрок, по умолчанию называется `'start'` (можно изменить с помощью параметра `startScene` в файле `package.json`, как сделано в примере `quest`)
- для смены сцен существует функция `player.goTo '<sceneID>'`, при этом происходит запрос данных для отображения у серверной части каждого компонента сцены, и эти данные отправляются на клиент, где происходит обновление компонент уже на странице.

## Компоненты

- вкратце, сцена - это набор компонент
- рассмотрим пример:
```coffeescript
scene 'first',
  title: 'Начало квеста'
  desc: 'Мы находимся в самом начале нашего пути'
  ways: [
    ['Вперед', 'long road']
    ['Налево', 'left']
    ['Направо', 'right']
  ]
```
- здесь `'first'` - это название сцены, по которому на нее в дальнейшем можно будет ссылаться
- `title` - это компонент, с аргументом `'начало квеста'`
- desc аналогичен `title`
- `ways` - это компонент, с аргументом массивом сцен, в которые можно осуществить переход из текущей
- исходный код компонент находится в каталоге `src`, в папках, имена которых совпадают с заданными здесь именами - desc, title, ways
- обычно компонент состоит из клиентской части (подпапка `src/<name>/client`) и серверной (`src/<name>/server`)
- также может присутствовать lib-часть (как в примере maze - `src/maze/lib`), в которой находится код, общий для клиента и для сервера
- любой из этих частей может и не быть, но хотя бы `client` или `server` должно присутствовать, иначе движок не сможет инициализировать компонент

# dev-server

Во время разработки на локальной машине, запуск игры происходит через dev-server, в задачи которого входит:

- компиляция клиентских coffee-файлов, объединение их в один скрипт и отдача по запросу с главной страницы
- отдача статики из папки /res/ (если такая есть в проекте)
- слежение за изменениями в файлах проекта, и как только файл изменился:
  - если он находится в клиентской части, то происходит его компиляция и пересборка общего клиентского скрипта
  - если файл находится в серверной части, то перезапускается ядро движка, пересчитываются все сцены и компоненты
  - если файл находится в общей папке `lib`, то совершаются оба действия как для клиента и сервера
  - плюс при любых изменениях в файлах, на открытую страницу браузера (по дополнительному dev-websocket’у) передается команда на обновление, и соответственно страница обновляется, подтягивая клиентские изменения и также заодно серверные.
- для лучшего понимания работы dev-server'а можно запустить какой-либо из примеров и, редактируя разные файлы, смотреть в консоли, как происходит перезапуск игры и обновление страницы с игрой.

# gui

Рендеринг игры реализован следующим образом:
- в коде клиентской части компонент мы можем использовать такие функции как: div, span, img, form, center, и т.д. (с полным списком доступных элементов можно ознакомиться в файле `gui/elements.coffee`)
- dev-server - при упаковке всех файлов в общий бандл - подставит необходимые вызовы конструкторов элементов
- для примера возьмем отображение заголовка сцены в примере quest:
```coffeescript
center ->
  div html: text
```
- здесь происходит создание блока `center`, внутри которого располагается `div`-элемент с текстом заголовка.
- элементы gui, которые могут иметь потомков, реализуются через использование функции, к примеру следующий код:
```coffeescript
div pos: [10, 20], ->
  span text: 'asdf'
  img src: '..'
```
создаст div с координатами \[10,20\] и внутри него 2 элемента: span и img. Здесь внутри создания div’а, будет вызвана переданная функция и все элементы, которые создаются внутри нее, будут добавлены к их родителю. Сам же div будет автоматически добавлен к div’у всего компонента (это реализуется в движке).

- у каждого объекта, создаваемого модулем gui, есть следующий набор функций:

  - update: (props)-> обновление элемента с заданием его свойств
  - clear: -> очищает элемент от его потомков
  - remove: -> удаляет элемент из DOM
  - append: (next)-> добавляет элементы к заданному через callback-функцию, выглядит это примерно так:
```
    block = div style: {...}
    block.append ->
      div ...
      span ...
      button ...
```
  - те элементы, что были созданы внутри callback-функции, будут автоматически добавлены как потомки к элементу-родителю block.
  - также append можно вызывать с аргументом-gui-объектом, который будет добавлен к вызываемому.

- у элементов помимо стандартных html-свойств могут еще быть дополнительные, задаваемые через функции-экстендеры (папка `gui/extenders/`), такие как:
- `pos`:
  - может быть массивом из 1-4 элементов, по порядку - \['left', 'top', 'width', 'height'\]
  - может быть объектом со следующими параметрами: {left, top, right, bottom, width, height}
  - у элемента с этим экстендером устанавливается style.position = 'absolute'
  - если передается значение в виде числа (10, 20, ...) то к нему добавляется ‘px’ (получится ‘10px’, ‘20px’), иначе значение берется как есть - ‘100%’, ‘70em’
  - примеры:
  - `div pos: [10, 10, 200, '100%']`
  - `span pos: {left: 20, top: 30}`

- `click`: для настольных браузеров аналогичен событию ‘click’, на мобильных устройствах реализовано через touch-события, чтобы избежать паузы в 300 мсек, которую автоматически делают мобильные браузеры;
- `visible`: true|false, просто более удобный способ работы с style.display = 'none'
- `text`: задает textContent элемента
- `html`: задает innerHTML элемента
- `style`: обычно просто прописывает свойства к стилю объекта, но также содержит несколько своих экстендеров (gui/extenders/style/):
   - `transform`: добавляет префиксы webkitTransform и msTransform для старых браузеров
   - `userSelect`: true|false: добавляет префиксы для различных браузеров, чтобы сделать объект не выделяемым
   - `gray`: для включения черно-белого режима отображения элемента

- и другие...

# rpc

В движке имеется механизм удаленного вызова процедур (remote procedure call, rpc). Технически он реализован с использованием WebSocket (с fallback’ом на XMLHttpRequest, если по каким-то причинам веб-сокет не доступен), и работает следующим образом:
- при создании клиентской части компоненты, ей во втором аргументе передается функция remote.
- вызов этой функции осуществляет передачу сообщения на сервер. Рассмотрим несколько примеров вызова:
  - `remote 'auth.enter', login, password` - вызывает функцию enter компонента auth с аргументами login, password
  - `remote 'chat.addMessage', 'hello'` - вызов функции addMessage компонента chat, с аргументом 'hello'
  - `remote 'goBack'` - вызывает функцию goBack для текущего компонента (в котором вызывается remote)
  - `remote 'way', 2` - вызываем функцию way текущего компонента, с аргументом 2
- если имя компоненты при указании функции задано не было, то автоматически подставится имя текущего компонента, из которого вызывается remote()
- на сервере происходит следующее:
  - приходящее сообщение разбирается на аргументы: первый аргумент задает имя компоненты и функции в нем, остальные просто передаются дальше
  - движок ищет в текущей сцене игрока компоненту с переданным именем (или среди компонент игры, если в сцене нет)
  - если найден, то ищется объект с именем `$remotes$`
  - если найден, то в нем ищется функция с переданным именем
  - если найдена, то она вызывается с первым аргументом - текущим игроком и плюс все остальные аргументы, пришедшие с клиента, если таковые были.

- Обратный процесс (с сервера на клиент) происходит похожим образом за исключением того, что первым аргументом надо передать объект player, для которого отправляется сообщение.

# storage

Для персистентного хранения и обновления данных на сервере реализован модуль storage. Пример работы с ним можно посмотреть в `maze/server.coffee` (объект `storage`). Если при запуске игры движок обнаруживает папку `data` и в ней файл `data.json` - то используется персистентная запись изменений в файл, иначе происходит работа с памятью, которая при перезапусках сервера, соответственно, не сохраняется.

# router

Имеется также довольно простой модуль для работы с роутингом - `router`. Обработчики задаются следующим образом:
- `router.get['/info'] = (req, res)->` - обработчик GET запроса
- `router.post['/forum/:thread/:page'] = (req, res, player)->` - обработчик POST запроса, где третьим аргументом передается объект игрока, если игрок сейчас онлайн, иначе null. Значения параметров `:thread` и `:page` помещаются в объект `req.params`.
Более подробно с работой этого модуля можно ознакомиться по тестовым сценариям в `test/router/router.test.coffee`

Email для связи с автором: progvlad7@gmail.com
